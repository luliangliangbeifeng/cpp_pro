主要参考：[C++设计模式系列文章](https://zhuanlan.zhihu.com/p/94877789)



### 行为型设计模式

对在不同的对象之间划分责任和算法的抽象化，行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。
**作用：**通过行为型模式，可以更加清晰地划分类与对象的职责，并研究**系统在运行时实例对象之间的交互**。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。

------

### 责任链模式

##### 定义

- **避免将一个请求的发送者和接收者耦合在一起，让多个对象都有机会处理请求。将接收请求的对象连接成一条链，并且沿着这条链传递请求，直到有一个对象能够处理它为止。**

##### 模式结构

- **Handler（抽象处理者）**：抽象处理者一般为抽象类，声明了一个处理请求的接口handleRequest()，定义了一个抽象处理者类型的对象，作为其对下家的引用，通过该引用可以形成一条责任链。
- **ConcreteHandler（具体处理者）**： 是抽象处理者的子类，实现了处理请求的接口。在具体的实现中，如果该具体处理者能够处理该请求，就处理它，否则将该请求转发给后继者。具体处理者可以访问下一个对象。

##### 优点

- 将请求的接收者和处理者解耦，客户端无需知道具体处理者，只针对抽象处理者编程，简化了客户端编程过程，降低系统耦合度；
- 在系统中增加一个新的处理者时，只需要继承抽象处理者，重新实现handleRequest()接口，无需改动原有代码，符合开闭原则；
- 给对象分配职责时，职责链模式赋予系统更多灵活性。

##### 缺点

- 请求没有一个明确的接收者，有可能遇到请求无法响应的问题；
- 比较长的职责链，其处理过程会很长。
- 建立职责链的工作是在客户端进行，如果建立不当，可能导致循环调用或者调用失败。

##### 适用环境

- 有多个对象处理同一个请求，具体由谁来处理是在运行时决定，客户端只需发出请求到职责链上，而无需关心具体是谁来处理；
- 可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变职责链中各个处理者之间的上下级关系。

------

### 命令模式

##### 定义

命令模式可以将请求（命令）的发送者与接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道请求是如何完成的。下面是比较晦涩难懂的命令模式的定义：

- **将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。**

##### 模式结构

- **Command（抽象命令类）**：是一个抽象类，声明了用于执行命令的接口。
- **ConcreteCommand（具体命令类）**：具体的命令类，实现了执行命令的接口execute()，它对应具体的接收者对象，将接收者（Receiver）的动作action()绑定其中。在execu()方法中将调用接收者的动作action()。（这就是定义中的“将请求封装成一个对象”的体现）
- **Invoker（调用者）**：请求的发送者，通过命令对象来执行请求。一个调用者不需要在设计时确定其接收者，所以调用者通过聚合，与命令类产生关联。**具体实现中，可以将一个具体命令对象注入到调用者中，再通过调用具体命令对象的execute()方法，实现简介请求命令执行者（接收者）的操作**。
- **Receiver（接收者）**： 实现处理请求的具体操作（action）。

##### 优点

- 降低系统耦合度，将命令的请求者与接收者分离解耦，请求者和发送者不存在直接关联，各自独立互不影响。
- 便于扩展：新的命令很容易加入到系统中，且符合开闭原则。
- 较容易实现命令队列或宏命令。
- 为请求的撤销和回复操作提供了一种设计实现方案。

##### 缺点

- 命令模式可能导致系统中有过多的具体命令类，增加了系统中对象的数量。

##### 适用环境

- 系统需要将请求发送者和接收者解耦，使得发送者和接收者互不影响。
- 系统需要在不同时间指定请求、将请求排队和执行请求。
- 系统需要支持命令的撤销和恢复操作。
- 系统需要将一组操作组合在一起形成宏命令。