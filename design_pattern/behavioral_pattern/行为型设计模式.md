主要参考：[C++设计模式系列文章](https://zhuanlan.zhihu.com/p/94877789)



### 行为型设计模式

对在不同的对象之间划分责任和算法的抽象化，行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。
**作用：**通过行为型模式，可以更加清晰地划分类与对象的职责，并研究**系统在运行时实例对象之间的交互**。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。

------

### 责任链模式

##### 定义

- **避免将一个请求的发送者和接收者耦合在一起，让多个对象都有机会处理请求。将接收请求的对象连接成一条链，并且沿着这条链传递请求，直到有一个对象能够处理它为止。**

##### 模式结构

- **Handler（抽象处理者）**：抽象处理者一般为抽象类，声明了一个处理请求的接口handleRequest()，定义了一个抽象处理者类型的对象，作为其对下家的引用，通过该引用可以形成一条责任链。
- **ConcreteHandler（具体处理者）**： 是抽象处理者的子类，实现了处理请求的接口。在具体的实现中，如果该具体处理者能够处理该请求，就处理它，否则将该请求转发给后继者。具体处理者可以访问下一个对象。

##### 优点

- 将请求的接收者和处理者解耦，客户端无需知道具体处理者，只针对抽象处理者编程，简化了客户端编程过程，降低系统耦合度；
- 在系统中增加一个新的处理者时，只需要继承抽象处理者，重新实现handleRequest()接口，无需改动原有代码，符合开闭原则；
- 给对象分配职责时，职责链模式赋予系统更多灵活性。

##### 缺点

- 请求没有一个明确的接收者，有可能遇到请求无法响应的问题；
- 比较长的职责链，其处理过程会很长。
- 建立职责链的工作是在客户端进行，如果建立不当，可能导致循环调用或者调用失败。

##### 适用环境

- 有多个对象处理同一个请求，具体由谁来处理是在运行时决定，客户端只需发出请求到职责链上，而无需关心具体是谁来处理；
- 可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变职责链中各个处理者之间的上下级关系。

------

### 命令模式

##### 定义

命令模式可以将请求（命令）的发送者与接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道请求是如何完成的。下面是比较晦涩难懂的命令模式的定义：

- **将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。**

##### 模式结构

- **Command（抽象命令类）**：是一个抽象类，声明了用于执行命令的接口。
- **ConcreteCommand（具体命令类）**：具体的命令类，实现了执行命令的接口execute()，它对应具体的接收者对象，将接收者（Receiver）的动作action()绑定其中。在execu()方法中将调用接收者的动作action()。（这就是定义中的“将请求封装成一个对象”的体现）
- **Invoker（调用者）**：请求的发送者，通过命令对象来执行请求。一个调用者不需要在设计时确定其接收者，所以调用者通过聚合，与命令类产生关联。**具体实现中，可以将一个具体命令对象注入到调用者中，再通过调用具体命令对象的execute()方法，实现简介请求命令执行者（接收者）的操作**。
- **Receiver（接收者）**： 实现处理请求的具体操作（action）。

##### 优点

- 降低系统耦合度，将命令的请求者与接收者分离解耦，请求者和发送者不存在直接关联，各自独立互不影响。
- 便于扩展：新的命令很容易加入到系统中，且符合开闭原则。
- 较容易实现命令队列或宏命令。
- 为请求的撤销和回复操作提供了一种设计实现方案。

##### 缺点

- 命令模式可能导致系统中有过多的具体命令类，增加了系统中对象的数量。

##### 适用环境

- 系统需要将请求发送者和接收者解耦，使得发送者和接收者互不影响。
- 系统需要在不同时间指定请求、将请求排队和执行请求。
- 系统需要支持命令的撤销和恢复操作。
- 系统需要将一组操作组合在一起形成宏命令。

------

### 解释器模式

##### 定义

- **给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。**

解释器模式需要解决的是，如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构件一个解释器，该解释器通过解释这些句子，来解决该问题。解释器模式描述了如何为简单的语言定义一个文法，如何在该语言中表示一个句子，以及如何解释这些句子。

##### 模式结构

- **AbstractExpression（抽象表达式）**：声明了抽象的解释操作interpret()，是所有终结符表达式和非终结符表达式的基类；
- **TerminalExpression（终结符表达式）**：**终结符是文法规则的组成元素中最基本的语言单位，不能再分解。**终结符表达式实现了与文法规则中终结符相关的解释操作，句子中的每一个终结符都是该类的一个实例。
- **NonterminalExpression（非终结符表达式）**：实现了文法规则中非终结符的解释操作，因为非终结符表达式同样可以包含终结符表达式，所以终结符表达式可以是非终结符表达式的成员。
- **Context（环境类）**：即上下文类，用于存储解释器之外的一些全局信息，通常临时存储需要解释的语句。

##### 优点

- 易于改变和扩展文法，在解释器中使用类表示语言的文法规则，可以通过继承等机制类改变或扩展文法；
- 每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言；
- 如果要增加新的解释表达式，只需增加一个新的终结符表达式或非终结符表达式类，无需修改原有代码，符合开闭原则。

##### 缺点

- **对于复杂文法难以维护**。在解释器模式中每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会大量增加，导致系统难以管理和维护；
- 执行效率低，**因为解释器模式中有大量循环和递归调用**。

##### 适用环境

- 一些重复出现的问题可以用一种简单的语言进行表达；
- 一个语言的文法较为简单；
- 不考虑执行效率的问题时可以使用解释器模式。

------

### 迭代器模式

##### 定义

- **提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。**

通过引入迭代器，可以将数据的遍历功能从聚合对象中分离出来，这样一来，聚合对象只需负责存储数据，而迭代器对象负责遍历数据，使得聚合对象的职责更加单一，符合单一职责原则。

##### 模式结构

- **Iterator（抽象迭代器）**：声明了访问和遍历聚合对象元素的接口，如first()方法用于访问聚合对象中第一个元素，next()方法用于访问下一个元素，hasNext()判断是否还有下一个元素，currentItem()方法用于获取当前元素。
- **ConcreteIterator（具体迭代器）**：实现抽象迭代器声明的方法，通常具体迭代器中会专门用一个变量（称为**游标**）来记录迭代器在聚合对象中所处的位置。
- **Aggregate（抽象聚合类）**：用于存储和管理元素对象，声明一个创建迭代器的接口，其实是一个**抽象迭代器工厂**的角色。
- **ConcreteAggregate（具体聚合类）**：实现了方法createIterator()，该方法返回一个与该具体聚合类对应的具体迭代器ConcreteIterator的实例。

##### 优点

- 支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多个遍历方式。
- 简化了聚合类，使得聚合类的职责更加单一；
- 迭代器模式中引入抽象层，易于增加新的迭代器类，便于扩展，符合开闭原则。

##### 缺点

- 将聚合类中存储对象和管理对象的职责分离，增加新的聚合类时同样需要考虑增加对应的新的迭代器类，类的个数成对增加，不利于系统管理和维护；
- 设计难度较大，需要充分考虑将来系统的扩展。

##### 适用环境

- 访问一个聚合对象而无需暴露它的内部结构；
- 需要为一个聚合对象提供多种遍历方法。

------

### 中介者模式

##### 定义

- **定义一个对象来封装一系列对象的交互。中介者模式使各个对象之间不需要显示地相互引用，从而使其耦合松散，而且用户可以独立地改变它们之间的交互。**

如果一个系统里各个对象之间存在多对多的相互关系，可以将对象之间的一些交互行为从各个对象中分离出来，集中封装在一个中介者对象中，使其耦合松散，并由中介者统一协调。通过中介者，对象之间的多对多关系就简化了相对更简单的一对多关系。 

##### 模式结构

- **Mediator（抽象中介者）**：声明一个用于与各个同事对象之间交互的接口，通常声明一个注册方法，用于增加同事对象；
- **ConcreteMediator（具体中介者）**：实现上面的接口，协调各个同事对象来实现协作行为，维持对各个同事对象的引用；
- **Colleague（抽象同事类）**：声明各个同事类公有的接口，**同时维持了一个对抽象中介者类的引用**；
- **ConcreteColleague（具体同事类）**： 具体实现接口，具体同事类只需与中介者通信，通过中介者完成与其他同事类的通信。

中介者模式的核心在于引入了中介者类，中介者类承担了两个层次的职责：

- 结构上起中转作用：通过中介者的中转，各个同事之间不必再相互显示调用或引用，只需通过中介者实现间接调用的目的；
- 行为上起协调作用：中介者可以进一步地将同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不必指出中介者具体该如何操作，中介者根据封装在自身内部的协调逻辑对同事的请求进一步处理，将同事成员之间的关系行为进行分离和封装。

##### 优点

- 简化了对象之间的交互，通过中介者，对象之间的多对多关系就简化了相对更简单的一对多关系；
- 可将各个同事对象解耦，利于各个同事之间的松散耦合，可独立地改变和复用每一个同事对象，增加新的中介者和同事都比较方便，符合开闭原则；
- 可减少子类生成，将原本分布于多个对象之间的行为封装在一起，只需生成新的具体中介者类就可以改变这些行为。 

##### 缺点

- 具体中介者类中包含了大量与同事之间交互的细节和逻辑，可能使得中介者类很复杂以至于难以管理维护。

##### 适用环境

- 系统中的对象之间存在复杂的交互关系，使得系统内逻辑错综复杂，难以管理；
- 一个对象引用了其他很多对象，并直接和这些对象交互，导致该对象难以复用。

------

### 备忘录模式

##### 定义

- **在不破坏封装的前提下捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。**

##### 模式结构

- **Originator（原发器）**：通过创建一个备忘录类存储当前的内部状态，也可以使用备忘录来恢复其内部状态，通常是将系统中需要保存内部状态的类设计为原发器；
- **Memento（备忘录）**：用于存储原发器的内部状态。备忘录的设计可以参考原发器的设计，根据需要确定备忘录类中的属性；**除了原发器类对象，不允许其他对象修改备忘录**。
- **Caretaker（负责人）**：负责保存备忘录，可以存储一个或多个备忘录对象，但是负责人只负责保存对象，不能修改对象，也不必知道对象的实现细节。（看好了，负责人可以存储多个备忘录对象，想一想这有什么用？是不是可以保存多个历史状态？实现多步撤销操作了）

##### 优点

- 实现状态恢复、撤销操作的功能，用户可以恢复到指定的历史状态，让软件系统更加人性化；
- 备忘录封装了信息，除了原生器以外，其他对象访问不了备忘录的代码；

##### 缺点

- 资源消耗大。如果需要保存原生器对象的多个历史状态，那么将创建多个备忘录对象；或者如果原生器对象的很多状态都需要保存，也将消耗大量存储资源。

##### 适用环境

- 保存一个对象的历史状态，系统需要设计回退或者撤销功能；
- 备忘录类可以封装一个对象的历史状态，避免对象的历史状态被外界修改。

------

### 观察者模式

##### 定义

- **定义对象之间的一种一对多的依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象都得到通知并被自动更新。**

##### 模式结构

- **Subject（目标）**：是被观察的对象，目标中定义了一个观察者的集合，即一个目标可能会有多个观察者，通过attach()和detach()方法来增删观察者对象。目标声明了通知方法notify()，用于在自身状态发生改变时通知观察者。
- **ConcreteSubject（具体目标）**：具体目标实现了通知方法notify()，同时具体目标有记录自身状态的属性和成员方法；
- **Observer（观察者）**：观察者将对接收到的目标发生改变的通知做出自身的反应，抽象层声明了更新方法update()；
- **ConcreteObserver（具体观察者）**： 实现了更新方法update()，具体观察者中维护了一个具体目标对象的引用（指针），用于存储目标的状态。

##### 优点

- 观察者模式实现了稳定的消息更新和传递的机制，通过引入抽象层可以扩展不同的具体观察者角色；
- **支持广播通信**，所有已注册的观察者（添加到目标列表中的对象）都会得到消息更新的通知，**简化了一对多设计的难度**；
- **符合开闭原则**，增加新的观察者无需修改已有代码，在具体观察者与观察目标之间不存在关联关系的情况下增加新的观察目标也很方便。

##### 缺点

- 代码中**观察者和观察目标相互引用**，存在循环依赖，观察目标会触发二者循环调用，有引起系统崩溃的风险；
- 如果一个观察目标对象有很多直接和简介观察者，将所有的观察者都通知到会耗费大量时间。

##### 适用环境

- 一个对象的改变会引起其他对象的联动改变，但并不知道是哪些对象会产生改变以及产生什么样的改变；
- 如果需要设计一个链式触发的系统，可是使用观察者模式；
- 广播通信、消息更新通知等场景。

------

### 策略模式

##### 定义

- **定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法可以独立于使用它的客户而变化。**

##### 模式结构

- **Context（上下文类）** ：上下文类是使用算法的角色，可以在解决不同具体的问题时实例化不同的具体策略类对象；
- **Strategy（抽象策略类）**：声明算法的方法，抽象层的设计使上下文类可以无差别的调用不同的具体策略的方法；
- **ConcreteStrategy（具体策略类）**：实现具体的算法。

##### 优点

- **符合开闭原则**，策略模式易于扩展，增加新的算法时只需继承抽象策略类，新设计实现一个具体策略类即可；
- 客户端可以无差别地通过公共接口调用，利用**里式替换原则**，灵活使用不同的算法策略；
- 提供了一个算法族管理机制和维护机制。

##### 缺点

- 客户端必须要知道所有的策略，以便在使用时按需实例化具体策略；
- 系统会产生很多单独的类，增加系统中类的数量；
- 客户端在同一时间只能使用一种策略。

##### 适用环境

- 系统需要在一个算法族中动态选择一种算法，可以将这些算法封装到多个具体算法类中，这些算法类都有共同的基类，即可以通过一个统一的接口调用任意一个算法，客户端可以使用任意一个算法；
- 不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装与算法相关的数据结构，可以提高算法的安全性。

------

### 访问者模式

##### 定义

- **表示一个作用于某对象结构中的各个元素的操作。访问者模式让用户可以在不改变各元素的前提下定义作用于这些元素的新操作。**

  访问者模式是一种较为复杂的行为型设计模式，具有**访问者**和**被访问元素**两个主要的角色。被访问的元素常常有不同的类型，不同的访问者可以对它们提供不同的访问方式。被访问元素通常不是单独存在，而是以集合的形式存在于一个**对象结构**中，访问者可以遍历该对象结构，以逐个访问其中的每一个元素。

##### 模式结构

- **Visitor（抽象访问者）：**抽象类，声明了访问对象结构中不同具体元素的方法，由方法名称可知该方法将访问对象结构中的某个具体元素；
- **ConcreteVisitor（具体访问者）：**访问某个具体元素的访问者，实现具体的访问方法；
- **Element（抽象元素）：**抽象类，一般声明一个accept()的方法，用于接受访问者的访问，accept()方法常常以一个抽象访问者的指针作为参数；
- **ConcreteElement（具体元素）：**针对具体被访问的元素，实现accept()方法；
- **ObjectStructure（对象结构）：**元素的集合，提供了遍历对象结构中所有元素的方法。对象结构存储了不同类型的元素对象，以供不同的访问者访问。

##### 优点

- 增加新的访问者很方便，即增加一个新的具体访问者类，定义新的访问方式，无需修改原有代码，符合开闭原则；
- 被访问元素集中在一个对象结构中，类的职责更清晰，利于对象结构中元素对象的复用；

##### 缺点

- 增加新的元素类很困难，增加新的元素时，在抽象访问者类中需要增加一个对新增的元素方法的声明，即要修改抽象访问者代码；此外还要增加新的具体访问者以实现对新增元素的访问，不符合开闭原则；
- 破坏了对象的封装性，访问者模式要求访问者对象访问并调用每一个元素对象的操作，那么元素对象必须暴露自己的内部操作和状态，否则访问者无法访问。

------

### 模板模式

##### 定义

- **定义一个操作中的算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。**

##### 模式结构

- **AbstractClass（基类）：**即抽象类，在基类中定义或声明了一系列基本操作method，这些操作是具体或者抽象的，每一个操作都对应算法的一个步骤，在其派生类中可以重定义。基类中定义了一个模板方法（template method），它规定了算法的流程框架，模板方法由基类定义或声明的一系列基本操作按照一定流程实现。
- **ConcreteClass（派生类）**：实现在基类中声明的抽象方法，也可以覆盖在基类中已经实现的方法。

##### 优点

- 在基类中定义算法的框架，并声明一些流程方法，由具体派生类实现细节，派生类中的实现并不会影响基类定义的算法的框架流程；
- 公共行为在基类中提供实现，有利于代码复用；
- 派生类可以覆盖基类的方法，重新实现某些方法，具有灵活性；
- 可以很方便的扩展和更换派生类而不影响基类和其他派生类，**符合开闭原则和单一职责原则**。

##### 缺点

- 模板方法模式要为每一个不同的基本方法提供一个派生类，如果基类中基本方法很多，那系统中会定义很多个派生类，导致类的个数很多，系统更加庞大。

##### 适用环境

- 分割复杂算法，可以将算法的框架流程定义在基类中，设计为模板方法；而具体的细节由派生类设计实现；
- 各个派生类的公共部分提取到基类中，以实现代码复用；
- 派生类需要覆盖基类的某些方法。

