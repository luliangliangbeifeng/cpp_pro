主要参考：[C++设计模式系列文章](https://zhuanlan.zhihu.com/p/94877789)



### 行为型设计模式

对在不同的对象之间划分责任和算法的抽象化，行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。
**作用：**通过行为型模式，可以更加清晰地划分类与对象的职责，并研究**系统在运行时实例对象之间的交互**。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。

------

### 责任链模式

##### 定义

- **避免将一个请求的发送者和接收者耦合在一起，让多个对象都有机会处理请求。将接收请求的对象连接成一条链，并且沿着这条链传递请求，直到有一个对象能够处理它为止。**

##### 模式结构

- **Handler（抽象处理者）**：抽象处理者一般为抽象类，声明了一个处理请求的接口handleRequest()，定义了一个抽象处理者类型的对象，作为其对下家的引用，通过该引用可以形成一条责任链。
- **ConcreteHandler（具体处理者）**： 是抽象处理者的子类，实现了处理请求的接口。在具体的实现中，如果该具体处理者能够处理该请求，就处理它，否则将该请求转发给后继者。具体处理者可以访问下一个对象。

##### 优点

- 将请求的接收者和处理者解耦，客户端无需知道具体处理者，只针对抽象处理者编程，简化了客户端编程过程，降低系统耦合度；
- 在系统中增加一个新的处理者时，只需要继承抽象处理者，重新实现handleRequest()接口，无需改动原有代码，符合开闭原则；
- 给对象分配职责时，职责链模式赋予系统更多灵活性。

##### 缺点

- 请求没有一个明确的接收者，有可能遇到请求无法响应的问题；
- 比较长的职责链，其处理过程会很长。
- 建立职责链的工作是在客户端进行，如果建立不当，可能导致循环调用或者调用失败。

##### 适用环境

- 有多个对象处理同一个请求，具体由谁来处理是在运行时决定，客户端只需发出请求到职责链上，而无需关心具体是谁来处理；
- 可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变职责链中各个处理者之间的上下级关系。

------

### 命令模式

##### 定义

命令模式可以将请求（命令）的发送者与接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道请求是如何完成的。下面是比较晦涩难懂的命令模式的定义：

- **将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。**

##### 模式结构

- **Command（抽象命令类）**：是一个抽象类，声明了用于执行命令的接口。
- **ConcreteCommand（具体命令类）**：具体的命令类，实现了执行命令的接口execute()，它对应具体的接收者对象，将接收者（Receiver）的动作action()绑定其中。在execu()方法中将调用接收者的动作action()。（这就是定义中的“将请求封装成一个对象”的体现）
- **Invoker（调用者）**：请求的发送者，通过命令对象来执行请求。一个调用者不需要在设计时确定其接收者，所以调用者通过聚合，与命令类产生关联。**具体实现中，可以将一个具体命令对象注入到调用者中，再通过调用具体命令对象的execute()方法，实现简介请求命令执行者（接收者）的操作**。
- **Receiver（接收者）**： 实现处理请求的具体操作（action）。

##### 优点

- 降低系统耦合度，将命令的请求者与接收者分离解耦，请求者和发送者不存在直接关联，各自独立互不影响。
- 便于扩展：新的命令很容易加入到系统中，且符合开闭原则。
- 较容易实现命令队列或宏命令。
- 为请求的撤销和回复操作提供了一种设计实现方案。

##### 缺点

- 命令模式可能导致系统中有过多的具体命令类，增加了系统中对象的数量。

##### 适用环境

- 系统需要将请求发送者和接收者解耦，使得发送者和接收者互不影响。
- 系统需要在不同时间指定请求、将请求排队和执行请求。
- 系统需要支持命令的撤销和恢复操作。
- 系统需要将一组操作组合在一起形成宏命令。

------

### 解释器模式

##### 定义

- **给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。**

解释器模式需要解决的是，如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构件一个解释器，该解释器通过解释这些句子，来解决该问题。解释器模式描述了如何为简单的语言定义一个文法，如何在该语言中表示一个句子，以及如何解释这些句子。

##### 模式结构

- **AbstractExpression（抽象表达式）**：声明了抽象的解释操作interpret()，是所有终结符表达式和非终结符表达式的基类；
- **TerminalExpression（终结符表达式）**：**终结符是文法规则的组成元素中最基本的语言单位，不能再分解。**终结符表达式实现了与文法规则中终结符相关的解释操作，句子中的每一个终结符都是该类的一个实例。
- **NonterminalExpression（非终结符表达式）**：实现了文法规则中非终结符的解释操作，因为非终结符表达式同样可以包含终结符表达式，所以终结符表达式可以是非终结符表达式的成员。
- **Context（环境类）**：即上下文类，用于存储解释器之外的一些全局信息，通常临时存储需要解释的语句。

##### 优点

- 易于改变和扩展文法，在解释器中使用类表示语言的文法规则，可以通过继承等机制类改变或扩展文法；
- 每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言；
- 如果要增加新的解释表达式，只需增加一个新的终结符表达式或非终结符表达式类，无需修改原有代码，符合开闭原则。

##### 缺点

- **对于复杂文法难以维护**。在解释器模式中每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会大量增加，导致系统难以管理和维护；
- 执行效率低，**因为解释器模式中有大量循环和递归调用**。

##### 适用环境

- 一些重复出现的问题可以用一种简单的语言进行表达；
- 一个语言的文法较为简单；
- 不考虑执行效率的问题时可以使用解释器模式。

------

### 迭代器模式

##### 定义

- **提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。**

通过引入迭代器，可以将数据的遍历功能从聚合对象中分离出来，这样一来，聚合对象只需负责存储数据，而迭代器对象负责遍历数据，使得聚合对象的职责更加单一，符合单一职责原则。

##### 模式结构

- **Iterator（抽象迭代器）**：声明了访问和遍历聚合对象元素的接口，如first()方法用于访问聚合对象中第一个元素，next()方法用于访问下一个元素，hasNext()判断是否还有下一个元素，currentItem()方法用于获取当前元素。
- **ConcreteIterator（具体迭代器）**：实现抽象迭代器声明的方法，通常具体迭代器中会专门用一个变量（称为**游标**）来记录迭代器在聚合对象中所处的位置。
- **Aggregate（抽象聚合类）**：用于存储和管理元素对象，声明一个创建迭代器的接口，其实是一个**抽象迭代器工厂**的角色。
- **ConcreteAggregate（具体聚合类）**：实现了方法createIterator()，该方法返回一个与该具体聚合类对应的具体迭代器ConcreteIterator的实例。

##### 优点

- 支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多个遍历方式。
- 简化了聚合类，使得聚合类的职责更加单一；
- 迭代器模式中引入抽象层，易于增加新的迭代器类，便于扩展，符合开闭原则。

##### 缺点

- 将聚合类中存储对象和管理对象的职责分离，增加新的聚合类时同样需要考虑增加对应的新的迭代器类，类的个数成对增加，不利于系统管理和维护；
- 设计难度较大，需要充分考虑将来系统的扩展。

##### 适用环境

- 访问一个聚合对象而无需暴露它的内部结构；
- 需要为一个聚合对象提供多种遍历方法。

------

### 中介者模式

##### 定义

- **定义一个对象来封装一系列对象的交互。中介者模式使各个对象之间不需要显示地相互引用，从而使其耦合松散，而且用户可以独立地改变它们之间的交互。**

如果一个系统里各个对象之间存在多对多的相互关系，可以将对象之间的一些交互行为从各个对象中分离出来，集中封装在一个中介者对象中，使其耦合松散，并由中介者统一协调。通过中介者，对象之间的多对多关系就简化了相对更简单的一对多关系。 

##### 模式结构

- **Mediator（抽象中介者）**：声明一个用于与各个同事对象之间交互的接口，通常声明一个注册方法，用于增加同事对象；
- **ConcreteMediator（具体中介者）**：实现上面的接口，协调各个同事对象来实现协作行为，维持对各个同事对象的引用；
- **Colleague（抽象同事类）**：声明各个同事类公有的接口，**同时维持了一个对抽象中介者类的引用**；
- **ConcreteColleague（具体同事类）**： 具体实现接口，具体同事类只需与中介者通信，通过中介者完成与其他同事类的通信。

中介者模式的核心在于引入了中介者类，中介者类承担了两个层次的职责：

- 结构上起中转作用：通过中介者的中转，各个同事之间不必再相互显示调用或引用，只需通过中介者实现间接调用的目的；
- 行为上起协调作用：中介者可以进一步地将同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不必指出中介者具体该如何操作，中介者根据封装在自身内部的协调逻辑对同事的请求进一步处理，将同事成员之间的关系行为进行分离和封装。

##### 优点

- 简化了对象之间的交互，通过中介者，对象之间的多对多关系就简化了相对更简单的一对多关系；
- 可将各个同事对象解耦，利于各个同事之间的松散耦合，可独立地改变和复用每一个同事对象，增加新的中介者和同事都比较方便，符合开闭原则；
- 可减少子类生成，将原本分布于多个对象之间的行为封装在一起，只需生成新的具体中介者类就可以改变这些行为。 

##### 缺点

- 具体中介者类中包含了大量与同事之间交互的细节和逻辑，可能使得中介者类很复杂以至于难以管理维护。

##### 适用环境

- 系统中的对象之间存在复杂的交互关系，使得系统内逻辑错综复杂，难以管理；
- 一个对象引用了其他很多对象，并直接和这些对象交互，导致该对象难以复用。

------

### 备忘录模式

##### 定义

- **定义一个对象来封装一系列对象的交互。中介者模式使各个对象之间不需要显示地相互引用，从而使其耦合松散，而且用户可以独立地改变它们之间的交互。**

如果一个系统里各个对象之间存在多对多的相互关系，可以将对象之间的一些交互行为从各个对象中分离出来，集中封装在一个中介者对象中，使其耦合松散，并由中介者统一协调。通过中介者，对象之间的多对多关系就简化了相对更简单的一对多关系。 

##### 模式结构

- **Mediator（抽象中介者）**：声明一个用于与各个同事对象之间交互的接口，通常声明一个注册方法，用于增加同事对象；
- **ConcreteMediator（具体中介者）**：实现上面的接口，协调各个同事对象来实现协作行为，维持对各个同事对象的引用；
- **Colleague（抽象同事类）**：声明各个同事类公有的接口，**同时维持了一个对抽象中介者类的引用**；
- **ConcreteColleague（具体同事类）**： 具体实现接口，具体同事类只需与中介者通信，通过中介者完成与其他同事类的通信。

中介者模式的核心在于引入了中介者类，中介者类承担了两个层次的职责：

- 结构上起中转作用：通过中介者的中转，各个同事之间不必再相互显示调用或引用，只需通过中介者实现间接调用的目的；
- 行为上起协调作用：中介者可以进一步地将同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不必指出中介者具体该如何操作，中介者根据封装在自身内部的协调逻辑对同事的请求进一步处理，将同事成员之间的关系行为进行分离和封装。

##### 优点

- 简化了对象之间的交互，通过中介者，对象之间的多对多关系就简化了相对更简单的一对多关系；
- 可将各个同事对象解耦，利于各个同事之间的松散耦合，可独立地改变和复用每一个同事对象，增加新的中介者和同事都比较方便，符合开闭原则；
- 可减少子类生成，将原本分布于多个对象之间的行为封装在一起，只需生成新的具体中介者类就可以改变这些行为。 

##### 缺点

- 具体中介者类中包含了大量与同事之间交互的细节和逻辑，可能使得中介者类很复杂以至于难以管理维护。

##### 适用环境

- 系统中的对象之间存在复杂的交互关系，使得系统内逻辑错综复杂，难以管理；
- 一个对象引用了其他很多对象，并直接和这些对象交互，导