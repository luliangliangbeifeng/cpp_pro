主要参考：[C++设计模式系列文章](https://zhuanlan.zhihu.com/p/94877789)



### 创建型设计模式

- 创建型模式关注对象的创建过程，在软件开发中应用非常广泛。**创建型模式描述如何将对象的创建和使用分离，让用户在使用对象过程中无须关心对象的创建细节，从而降低系统耦合度，并且让系统易于修改和扩展。**

------

### 简单工厂模式

##### 定义

- 定义一个简单工厂类，它可以**根据参数的不同返回不同类的实例**，被创建的实例通常都具有共同的父类

##### 实现流程

- 设计一个抽象产品类，它包含一些公共方法的实现；
- 从抽象产品类中派生出多个具体产品类，具体产品类中实现具体产品生产的相关代码；
- 设计一个工厂类，工厂类中提供一个生产各种产品的工厂方法，该方法根据传入参数（产品名称）创建不同的具体产品类对象；
- 客户只需调用工厂类的工厂方法，并传入具体产品参数，即可得到一个具体产品对象。

##### 模式结构

- **工厂（Factory）**：根据客户提供的具体产品类的参数，创建具体产品实例；
- **抽象产品（AbstractProduct）**：具体产品类的基类，包含创建产品的公共方法；
- **具体产品（ConcreteProduct）**：抽象产品的派生类，包含具体产品特有的实现方法，是简单工厂模式的创建目标。

##### 优点

- 工厂类提供创建具体产品的方法，并包含一定判断逻辑，客户不必参与产品的创建过程；
- 客户只需要知道对应产品的参数即可，参数一般简单好记，如数字、字符或者字符串等。

##### 缺点

- **违背了开闭原则（对扩展开放，对修改关闭），即在扩展功能时修改了既有的代码**。另一方面，简单工厂模式所有的判断逻辑都在工厂类中实现，一旦工厂类设计故障，则整个系统都受之影响！

------

### 工厂模式

##### 定义

- 定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。**工厂方法模式让一个类的实例化延迟到其子类**。

##### 模式结构

- **抽象工厂（AbstractFactory）**：所有生产具体产品的工厂类的基类，提供工厂类的公共方法；

- 
- **具体工厂（ConcreteFactory）**：生产具体的产品
- **抽象产品（AbstractProduct）**：所有产品的基类，提供产品类的公共方法
- **具体产品（ConcreteProduct）**：具体的产品类

##### 优点

- 工厂方法用于创建客户所需产品，同时向客户隐藏某个具体产品类将被实例化的细节，用户只需关心所需产品对应的工厂；
- 工厂自主决定创建何种产品，并且创建过程封装在具体工厂对象内部，**多态性设计**是工厂方法模式的关键；
- 新加入产品时，无需修改原有代码，**增强了系统的可扩展性，符合开闭原则**。

##### 缺点

- 添加新产品时需要同时添加新的产品工厂，系统中类的数量成对增加，增加了系统的复杂度，更多的类需要编译和运行，增加了系统的额外开销；
- 工厂和产品都引入了抽象层，客户端代码中均使用的抽象层（***AbstractFactory***和***AbstractSportProduct*** ），增加了系统的抽象层次和理解难度。

**适用环境**

- 客户端不需要知道它所需要创建的对象的类；

- 抽象工厂类通过其子类来指定创建哪个对象（运用多态性设计和里氏代换原则）

  ------

### 抽象工厂模式

##### 定义

- **提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。**简言之，一个工厂可以提供创建多种相关产品的接口，而无需像工厂方法一样，为每一个产品都提供一个具体工厂。 

##### 模式结构

- 抽象工厂（AbstractFactory）：所有生产具体产品的工厂类的基类，提供工厂类的公共方法；
- 具体工厂（ConcreteFactory）：生产具体的产品
- 抽象产品（AbstractProduct）：所有产品的基类，提供产品类的公共方法
- 具体产品（ConcreteProduct）：具体的产品类

##### 优点

- 工厂方法用于创建客户所需产品，同时向客户隐藏某个具体产品类将被实例化的细节，用户只需关心所需产品对应的工厂；
- 新加入**产品系列**时，无需修改原有系统，增强了系统的可扩展性，符合开闭原则。

##### 缺点

- 在已有产品系列中添加新产品时需要修改抽象层代码，对原有系统改动较大，违背开闭原则

##### 适用环境

- 一系列/一族产品需要被同时使用时，适合使用抽象工厂模式；
- 产品结构稳定，设计完成之后不会向系统中新增或剔除某个产品

------

### 建造者模式

##### 定义

- ##### **将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。**

##### 模式结构

- 抽象建造者（AbstractBuilder）：创建一个Product对象的各个部件指定的抽象接口；

- 具体建造者（ConcreteBuilder）：实现AbstractBuilder的接口，实现各个部件的具体构造方法和装配方法，并返回创建结果。

- 产品（Product）：具体的产品对象

- 指挥者（Director）： 构建一个使用Builder接口的对象，安排复杂对象的构建过程，**客户端一般只需要与**

  **Director交互，指定建造者类型，然后通过构造函数或者setter方法将具体建造者对象传入Director**。它主要作用是：隔离客户与对象的生产过程，并负责控制产品对象的生产过程。

##### 优点

- 建造者模式中，客户端不需要知道产品内部组成细节，将产品本身和产品的创建过程分离，使同样的创建过程可以创建不同的产品对象；
- 不同建造者相互独立，并无任何挂链，方便替换。

##### 缺点

- 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，**如果产品之间的差异性很大，则不适合使用建造者模式**，因此其使用范围受到一定的限制。
-  如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大

##### 适用范围

- 需要生成的产品对象有复杂的内部结构（通常包含多个成员变量）；
- 产品对象内部属性有一定的生成顺序；
- 同一个创建流程适用于多种不同的产品。

------

### 原型模式

##### 定义

- **使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。**原型模式的工作原理是将一个原型对象传给要发动创建的对象（即客户端对象），这个要**发动创建的对象通过请求原型对象复制自己来实现创建过程**。从工厂方法角度而言，创建新对象的工厂就是原型类自己。软件系统中有些对象的创建过程比较复杂，且有时需要频繁创建，原型模式通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象，这就是原型模式的意图所在。

##### 模式结构

- **抽象原型类（AbstractPrototype）**：声明克隆clone自身的接口
- **具体原型类（ConcretePrototype）**：实现clone接口
- **客户端（Client）**：客户端中声明一个抽象原型类，根据客户需求clone具体原型类对象实例

##### 深拷贝/浅拷贝

- 在浅拷贝中，如果原型对象的成员变量是值类型（如int、double、char等基本数据类型），将复制一份给拷贝对象；如果原型对象的成员变量是引用/指针，**则将引用/指针指向的地址拷贝一份给拷贝对象**，即**原型对象和拷贝对象中的成员变量指向同一个地址**。
- 在深拷贝中，无论原型对象中的成员变量是值类型还是指针/引用类型，都将复制一份给拷贝对象。注意，**深拷贝中，指针/引用对象也会被拷贝一份给拷贝对象**。

##### 优点

- 当创建新的对象实例**较为复杂**时，原型模式可以简化创建过程，提高创建对象的效率；
- 可扩展：模式中提供了抽象原型类，具体原型类可适当扩展；
- 创建结构简单：创建工厂即为原型对象本身

##### 缺点

- 深克隆代码较为复杂；
- 每一个类都得配备一个clone方法，且该方法位于类的内部，修改时违背开闭原则；

##### 适用场景

- 当创建新的对象实例较为复杂时，原型模式可以简化创建过程；
- 结合优点第3条，需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少几个的组合状态，通过复制原型对象得到新实例，比通过使用构造函数创建一个新实例会更加方便。

------

