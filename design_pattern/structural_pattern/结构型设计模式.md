主要参考：[C++设计模式系列文章](https://zhuanlan.zhihu.com/p/94877789)



### 结构型设计模式

结构型模式描述如何将**类和对象组合**起来，形成更大的结构，就像搭积木，可以通过简单积木的组合形成复功能更为强大的积木。

- 类结构模式 : 由多个类可以组成一个更大的系统，在类结构模式中只存在**继承关系和实现关系**
- 对象结构模式 : 通过**关联关系**使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。根据合成复用原则，在系统中尽量使用关联关系来替代继承关系，因此大部分结构模式都是对象结构模式

------

### 适配器模式

##### 定义

- 将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作。
- **类适配器中，适配器类通过继承适配者类**，并重新实现适配者的具体接口来达到适配客户所需要的接口的目的。
- **对象适配器中，适配器类通过在类中实例化一个适配者类的对象**，并将其封装在客户所需功能的接口里，达到最终的适配目的。

##### 模式结构

适配器模式分为类适配器和对象适配器。

- **适配器类（Adapter）**：适配器与适配者之间是继承或实现关系；
- **适配者类（Adaptee）**：适配器与适配者之间是关联关系。
- **目标抽象类（Target）**：定义客户所需要的接口。

##### 优点

- 将目标类和适配者类解耦，引入一个适配器类实现代码重用，无需修改原有结构；
- 增加类的透明和复用，对于客户端而言，适配者类是透明的；
- 对象适配器可以把不同适配者适配到同一个目标（对象适配器）；

##### 缺点

- 对编程语言的限制：Java不支持多重继承，一次最多只能适配一个适配者类，不能同时适配多个适配者类；

##### 适用环境

- 系统需要使用一些现有的类，但这些类的接口不符合系统需要，或者没有这些类的源代码；
- 想创建一个重复使用的类，用于和一些彼此没有太大关联的类一起工作。

------

### 桥接模式

##### 定义

- **将抽象部分与它的实现部分解耦，使得两者都能够独立变化。**
- **桥接模式将两个独立变化的维度设计成两个独立的继承等级结构（而不会将两者耦合在一起形成多层继承结构），在抽象层将二者建立起一个抽象关联，该关联关系类似一座桥，将两个独立的等级结构连接起来**，故曰“桥接模式”。

##### 模式结构

- **Abstraction（抽象类）**：定义抽象类的接口（抽象接口），由聚合关系可知，抽象类中包含一个Implementor类型的对象，它与Implementor之间有**关联关系**，既可以包含抽象业务方法，也可以包含具体业务方法；

- **Implementor（实现类接口）**：定义实现类的接口，这个接口可以与Abstraction类的接口不同。一般而言，实现类接口只定义基本操作，而抽象类的接口还可能会做更多复杂的操作。

- **RefinedAbstraction（扩充抽象类）**：具体类，实现在抽象类中定义的接口，可以调用在Implementor中定义的方法；

- **ConcreteImplementor（具体实现类）**：具体实现了Implementor接口，在不同的具体实现类中实现不同的具体操作。运行时ConcreteImplementor将替换父类。

  简言之，在Abstraction类中维护一个**Implementor**类指针，需要采用不同的实现方式的时候只需要传入不同的**Implementor**派生类就可以了。

##### 优点

- 分离抽象接口与实现部分，使用对象间的关联关系使抽象与实现解耦；
- 桥接模式可以取代多层继承关系，多层继承违背单一职责原则，不利于代码复用；
- 桥接模式提高了系统可扩展性，某个维度需要扩展只需增加实现类接口或者具体实现类，而且不影响另一个维度，符合开闭原则。

##### 缺点

- 桥接模式难以理解，因为关联关系建立在抽象层，需要一开始就设计抽象层；
- 如何准确识别系统中的两个维度是应用桥接模式的难点。

**适用环境**

- 如果一个系统需要在抽象化和具体化之间增加灵活性，避免在两个层次之间增加继承关系，可以使用桥接模式在抽象层建立关联关系；

- 抽象部分和实现部分可以各自扩展而互不影响；

- 一个类存在多个独立变化的维度，可采用桥接模式。

  ------

### 桥接模式

##### 定义

- **组合多个对象形成树形结构以表示具有部分-整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象**。

##### 模式结构

- **Component（抽象构件）**：**Component**是一个抽象类，定义了构件的一些公共接口，这些接口是管理或者访问它的子构件的方法（如果有子构件），具体的实现在叶子构件和容器构件中进行；

- **Leaf（叶子构件）**：它代表树形结构中的叶子节点对象，叶子构件没有子节点，它实现了在抽象构件中定义的行为。对于抽象构件定义的管理子构件的方法，叶子构件可以通过抛出异常、提示错误等方式进行处理。

- **Composite（容器构件）** ：容器构件一方面具体实现公共接口，另一方面通过聚合关系包含子构件，子构件可以是容器构件，也可以是叶子构件；


##### 优点

- 清楚地定义分层次的复杂对象，表示出复杂对象的层次结构，让客户端忽略层次的差异；
- 客户端可以一致地使用层次结构中各个层次的对象，而不必关心其具体构件的行为如何实现；
- 在组合模式中增加新的叶子构件和容器构件非常方便，易于扩展，符合开闭原则；
- 为树形结构的案例提供了解决方案。

##### 缺点

- 子构件或容器构件的行为受限制，**因为它们来自相同的抽象层**。如果要定义某个容器或者某个叶子节点特有的方法，那么要求在运行时判断对象类型，增加了代码的复杂度。

**适用环境**

- 系统中需要用到树形结构；
- 系统中能够分离出容器节点和叶子节点；
- 具有整体和部门的层次结构中，能够通过某种方式忽略层次差异，使得客户端可以一致对待。

------

### 装饰器模式

##### 定义

- **动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供了一种比使用子类更加灵活的替代方案。** 装饰模式是一种用于替代继承的技术。通过一种无须定义子类的方式给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有对象的方法，还可以增加新的方法，以扩充原有类的功能。

##### 模式结构

- **Component（抽象构件）**：是具体构件类和装饰类的共同基类，声明了在具体构件中定义的方法，客户端可以一致的对待使用装饰前后的对象；
- **ConcreteComponent（具体构件）**：具体构件定义了构件具体的方法，装饰类可以给它增加更多的功能；
- **Decorator（抽象装饰类）**：用于给具体构件增加职责，但具体职责在其子类中实现。抽象装饰类通过聚合关系定义一个抽象构件的对象，通过该对象可以调用装饰之前构件的方法，并通过其子类扩展该方法，达到装饰的目的；
- **ConcreteDecorator（具体装饰类）**： 向构件增加新的功能。


##### 优点

- 对于扩展一个类的新功能，装饰模式比继承更加灵活；
- **动态扩展一个对象的功能**；
- **可以对一个对象进行多次装饰**；
- **具体构件类和具体装饰类可以独立变化和扩展**，符合开闭原则。

##### 缺点

- 装饰模式中会增加很多小的对象，对象的区别主要在于各种装饰的连接方式不同，而并不是职责不同，大量小对象的产生会占用较多的系统资源；
- 装饰模式比继承模式更灵活，但也更容易出错，更难于排错。

**适用环境**

- 在不影响其他对象的情况下，给单个对象动态扩展职责；
- 不适宜采用继承的方式进行扩展的时候，可以考虑使用装饰模式。

------

### 外观模式

##### 定义

- **为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。**

##### 模式结构

- **Facade（外观角色）**：外观角色可以知道多个相关子系统的功能，它将所有从客户端发来的请求委派给相应的子系统，传递给相应的子系统处理。
- **SubSystem（子系统角色）**：子系统是一个类，或者由多个类组成的类的集合，它实现子系统具体的功能。 


##### 优点

- 外观模式使得客户端不必关心子系统组件，减少了与客户端交互的对象的数量，简化了客户端的编程；
- 外观模式可以大大降低系统的耦合度；
- 子系统的变化并不需要修改客户端，只需要适当修改外观类即可；
- 子系统之间不会相互影响。

##### 缺点

- 如果需要增加或者减少子系统，需要修改外观类，**违反开闭原则**；
- 并不能限制客户端直接与子系统交互，但如果加强限制，又使得系统灵活度降低。

**适用环境**

- 为访问一系列复杂的子系统提供一个统一的、简单的入口，可以使用外观模式；
- 客户端与多个子系统之间存在很大依赖，但在客户端编程，又会增加系统耦合度，且使客户端编程复杂，可以使用外观模式。

------

### 享元模式

##### 定义

- **运用共享技术有效地支持大量细粒度对象的复用。**如果一个系统在运行时创建太多相同或者相似的对象，会占用大量内存和资源，降低系统性能。**享元模式通过共享技术实现相同或相似的细粒度对象的复用，提供一个享元池存储已经创建好的对象，并通过享元工厂类将享元对象提供给客户端使用**。
- **内部状态**：存储在享元对象内部，不会随着环境的改变而改变的，内部状态可以共享。比如围棋中棋子的形状、大小，不会随着外部变化而变化；比如字母A，无论谁使用，都是A，不会变化；
- **外部状态**：随环境变化而变化、不可以共享的状态，如棋子的位置、颜色，如每个字母的位置。外部状态一般由客户端保存，在使用时再传入到享元对象内部。不同的外部状态之间是相互独立的，棋子A和棋子B的位置可以不同，并且不会相互影响。

##### 模式结构

享元模式常常结合工厂模式一起使用，其结构包含抽象享元类、具体享元类、非共享具体享元类和享元工厂类：

- **Flyweight（抽象享元类）**：是一个抽象类，声明了具体享元类公共的方法，这些方法可以向外部提供享元对象的内部状态数据，也可以通过这些方法设置外部状态；
- **ConcreteFlyweight（具体享元类）**：具体实现抽象享元类声明的方法，具体享元类中为内部状态提供存储空间。**具体享元类常常结合[单例模式](https://blog.csdn.net/sinat_21107433/article/details/102649056)来设计实现，保证每个享元类对象只被创建一次，为每个具体享元类提供唯一的享元对象**。
- **UnsharedConcreteFlyweight（非共享具体享元类）**：并不是所有抽象享元类的子类都需要被共享，可以将这些类设计为非共享具体享元类；
- **FlyweightFactory（享元工厂类）**：用于创建并管理享元对象，针对抽象享元类编程，将各种具体享元类对象存储在一个享元池中，享元池一般设计为一个存储键值对的集合（或者其他类型的集合），可结合工厂模式设计。客户需要某个享元对象时，如果享元池中已有该对象实例，则返回该实例，否则创建一个新的实例，给客户返回新的实例，并将新实例保存在享元池中。


##### 优点

- 享元模式通过享元池存储已经创建好的享元对象，**实现相同或相似的细粒度对象的复用，大大减少了系统中的对象数量，节约了内存空间，提升了系统性能**；
- 享元模式通过内部状态和外部状态的区分，外部状态相互独立，客户端可以根据需求任意使用。

##### 缺点

- 享元模式需要增加逻辑来取分出内部状态和外部状态，增加了编程的复杂度；

**适用环境**

- 当一个系统中有大量重复使用的相同或相似对象时，使用享元模式可以节约系统资源；
- 对象的大部分状态都可以外部化，可以将这些状态传入对象中。

------

### 代理模式

##### 定义

- **给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。**

##### 模式结构

- **抽象主题角色（Subject）**：声明了代理主题角色和真实主题角色共同的一些接口，因此在任何可以使用真实主题对象的地方都可以使用代理主题角色（想一想代购是不是也是这样？），客户端通常针对抽象主题编程；
- **代理主题角色（Proxy）**：代理主题角色通过关联关系引用真实主题角色，因此可以控制和操纵真实主题对象；代理主题角色中提供一个与真实主题角色相同的接口（以在需要时代替真实主题角色），同时还可以在调用对真实主题对象的操作之前或之后增加新的服务和功能；
- **真实主题角色（RealSubject）**：真实主题角色是代理角色所代表的真实对象，提供真正的业务操作，客户端可以通过代理主题角色间接地调用真实主题角色中定义的操作。

在实际开发过程中，代理模式产生了很多类型：

- **远程代理（Remote Proxy）**：为一个位于不同地址空间的对象提供一个本地的代理对象。不同的地址空间可以在相同或不同的主机中。
- **虚拟代理（Virtual Proxy）**：当创建一个对象需要消耗大量资源时，可以先创建一个消耗较少资源的虚拟代理来表示，当真正需要时再创建。
- **保护代理（Protect Proxy）**：给不同的用户提供不同的对象访问权限。
- **缓冲代理（Cache Proxy）**：为某一个目标操作的结果提供临时存储空间，以使更多用户可以共享这些结果。
  智能引用代理（Smart Reference Proxy）：当一个对象被引用时提供一些额外的操作，比如将对象被调用的次数记录下来等。


##### 优点

- 代理模式能够协调调用者和被调用者，降低系统耦合度；
- 客户端针对抽象主题角色编程，如果要增加或替换代理类，无需修改源代码，符合开闭原则，系统扩展性好；
- 远程代理优点：为两个位于不同地址空间的对象的访问提供解决方案，可以将一些资源消耗较多的对象移至性能较好的计算机上，提高系统整体性能；
- 虚拟代理优点：通过一个资源消耗较少的对象来代表一个消耗资源较多的对象，节省系统运行开销；
- 缓冲代理优点：为某一个操作结果提供临时的存储空间，可以在后续操作中使用这些结果，缩短了执行时间；
- 保护代理优点：:控制对一个对象的访问权限，为不同客户提供不同的访问权限。

##### 缺点

- 增加了代理类和代理对象，增加了代理对象中的某些处理流程，可能会使得系统响应变慢；
- 有的代理模式（如远程代理）实现代码较为复杂。

**适用环境**

- 当客户端对象需要访问远程主机中的对象——可以使用远程代理；
- 当需要用一个资源消耗较少的对象来代表一个资源消耗较多的对象——虚拟代理；
- 当需要限制不同用户对一个独享的访问权限——保护代理；
- 当需要为一个频繁访问的操作结果提供临时存储空间——缓冲代理；
- 当需要为一个对象的访问提供一些额外的操作——智能引用代理。
  

