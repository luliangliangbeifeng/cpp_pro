主要参考：[C++设计模式系列文章](https://zhuanlan.zhihu.com/p/94877789)



### 结构型设计模式

结构型模式描述如何将**类和对象组合**起来，形成更大的结构，就像搭积木，可以通过简单积木的组合形成复功能更为强大的积木。

- 类结构模式 : 由多个类可以组成一个更大的系统，在类结构模式中只存在**继承关系和实现关系**
- 对象结构模式 : 通过**关联关系**使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。根据合成复用原则，在系统中尽量使用关联关系来替代继承关系，因此大部分结构模式都是对象结构模式

------

### 适配器模式

##### 定义

- 将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作。
- **类适配器中，适配器类通过继承适配者类**，并重新实现适配者的具体接口来达到适配客户所需要的接口的目的。
- **对象适配器中，适配器类通过在类中实例化一个适配者类的对象**，并将其封装在客户所需功能的接口里，达到最终的适配目的。

##### 模式结构

适配器模式分为类适配器和对象适配器。

- **适配器类（Adapter）**：适配器与适配者之间是继承或实现关系；
- **适配者类（Adaptee）**：适配器与适配者之间是关联关系。
- **目标抽象类（Target）**：定义客户所需要的接口。

##### 优点

- 将目标类和适配者类解耦，引入一个适配器类实现代码重用，无需修改原有结构；
- 增加类的透明和复用，对于客户端而言，适配者类是透明的；
- 对象适配器可以把不同适配者适配到同一个目标（对象适配器）；

##### 缺点

- 对编程语言的限制：Java不支持多重继承，一次最多只能适配一个适配者类，不能同时适配多个适配者类；

##### 适用环境

- 系统需要使用一些现有的类，但这些类的接口不符合系统需要，或者没有这些类的源代码；
- 想创建一个重复使用的类，用于和一些彼此没有太大关联的类一起工作。

------

### 桥接模式

##### 定义

- **将抽象部分与它的实现部分解耦，使得两者都能够独立变化。**

##### 模式结构

- **抽象工厂（AbstractFactory）**：所有生产具体产品的工厂类的基类，提供工厂类的公共方法；

- 
- **具体工厂（ConcreteFactory）**：生产具体的产品
- **抽象产品（AbstractProduct）**：所有产品的基类，提供产品类的公共方法
- **具体产品（ConcreteProduct）**：具体的产品类

##### 优点

- 工厂方法用于创建客户所需产品，同时向客户隐藏某个具体产品类将被实例化的细节，用户只需关心所需产品对应的工厂；
- 工厂自主决定创建何种产品，并且创建过程封装在具体工厂对象内部，**多态性设计**是工厂方法模式的关键；
- 新加入产品时，无需修改原有代码，**增强了系统的可扩展性，符合开闭原则**。

##### 缺点

- 添加新产品时需要同时添加新的产品工厂，系统中类的数量成对增加，增加了系统的复杂度，更多的类需要编译和运行，增加了系统的额外开销；
- 工厂和产品都引入了抽象层，客户端代码中均使用的抽象层（***AbstractFactory***和***AbstractSportProduct*** ），增加了系统的抽象层次和理解难度。

**适用环境**

- 客户端不需要知道它所需要创建的对象的类；

- 抽象工厂类通过其子类来指定创建哪个对象（运用多态性设计和里氏代换原则）

  ------

### 抽象工厂模式

##### 定义

- **提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。**简言之，一个工厂可以提供创建多种相关产品的接口，而无需像工厂方法一样，为每一个产品都提供一个具体工厂。 

##### 模式结构

- 抽象工厂（AbstractFactory）：所有生产具体产品的工厂类的基类，提供工厂类的公共方法；
- 具体工厂（ConcreteFactory）：生产具体的产品
- 抽象产品（AbstractProduct）：所有产品的基类，提供产品类的公共方法
- 具体产品（ConcreteProduct）：具体的产品类

##### 优点

- 工厂方法用于创建客户所需产品，同时向客户隐藏某个具体产品类将被实例化的细节，用户只需关心所需产品对应的工厂；
- 新加入**产品系列**时，无需修改原有系统，增强了系统的可扩展性，符合开闭原则。

##### 缺点

- 在已有产品系列中添加新产品时需要修改抽象层代码，对原有系统改动较大，违背开闭原则

##### 适用环境

- 一系列/一族产品需要被同时使用时，适合使用抽象工厂模式；
- 产品结构稳定，设计完成之后不会向系统中新增或剔除某个产品

------

### 建造者模式

##### 定义

- ##### **将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。**

##### 模式结构

- 抽象建造者（AbstractBuilder）：创建一个Product对象的各个部件指定的抽象接口；

- 具体建造者（ConcreteBuilder）：实现AbstractBuilder的接口，实现各个部件的具体构造方法和装配方法，并返回创建结果。

- 产品（Product）：具体的产品对象

- 指挥者（Director）： 构建一个使用Builder接口的对象，安排复杂对象的构建过程，**客户端一般只需要与**

  **Director交互，指定建造者类型，然后通过构造函数或者setter方法将具体建造者对象传入Director**。它主要作用是：隔离客户与对象的生产过程，并负责控制产品对象的生产过程。

##### 优点

- 建造者模式中，客户端不需要知道产品内部组成细节，将产品本身和产品的创建过程分离，使同样的创建过程可以创建不同的产品对象；
- 不同建造者相互独立，并无任何挂链，方便替换。

##### 缺点

- 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，**如果产品之间的差异性很大，则不适合使用建造者模式**，因此其使用范围受到一定的限制。
-  如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大

##### 适用范围

- 需要生成的产品对象有复杂的内部结构（通常包含多个成员变量）；
- 产品对象内部属性有一定的生成顺序；
- 同一个创建流程适用于多种不同的产品。

------

### 原型模式

##### 定义

- **使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。**原型模式的工作原理是将一个原型对象传给要发动创建的对象（即客户端对象），这个要**发动创建的对象通过请求原型对象复制自己来实现创建过程**。从工厂方法角度而言，创建新对象的工厂就是原型类自己。软件系统中有些对象的创建过程比较复杂，且有时需要频繁创建，原型模式通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象，这就是原型模式的意图所在。

##### 模式结构

- **抽象原型类（AbstractPrototype）**：声明克隆clone自身的接口
- **具体原型类（ConcretePrototype）**：实现clone接口
- **客户端（Client）**：客户端中声明一个抽象原型类，根据客户需求clone具体原型类对象实例

##### 深拷贝/浅拷贝

- 在浅拷贝中，如果原型对象的成员变量是值类型（如int、double、char等基本数据类型），将复制一份给拷贝对象；如果原型对象的成员变量是引用/指针，**则将引用/指针指向的地址拷贝一份给拷贝对象**，即**原型对象和拷贝对象中的成员变量指向同一个地址**。
- 在深拷贝中，无论原型对象中的成员变量是值类型还是指针/引用类型，都将复制一份给拷贝对象。注意，**深拷贝中，指针/引用对象也会被拷贝一份给拷贝对象**。

##### 优点

- 当创建新的对象实例**较为复杂**时，原型模式可以简化创建过程，提高创建对象的效率；
- 可扩展：模式中提供了抽象原型类，具体原型类可适当扩展；
- 创建结构简单：创建工厂即为原型对象本身

##### 缺点

- 深克隆代码较为复杂；
- 每一个类都得配备一个clone方法，且该方法位于类的内部，修改时违背开闭原则；

##### 适用场景

- 当创建新的对象实例较为复杂时，原型模式可以简化创建过程；
- 结合优点第3条，需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少几个的组合状态，通过复制原型对象得到新实例，比通过使用构造函数创建一个新实例会更加方便。

------

### 单例模式

##### 定义

- **确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。**

##### 模式结构

- 单例模式结构非常简单，只包含一个类，即单例类。为防止创建多个对象，其构造函数必须是私有的（外界不能访问）。另一方面，为了提供一个全局访问点来访问该唯一实例，单例类提供了一个公有方法getInstance来返回该实例。

##### 优点

- 单例模式提供了严格的对唯一实例的创建和访问
- 单例模式的实现可以节省系统资源

##### 缺点

- 如果某个实例负责多重职责但又必须实例唯一，那单例类的职责过多，这违背了单一职责原则
- 多线程下需要考虑线程安全机制
- 单例模式没有抽象层，不方便扩展

##### 适用场景

- 系统只需要一个实例对象
- 某个实例只允许有一个访问接口